#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEngine;
using Object = UnityEngine.Object;

namespace RCore.Editor
{
	public static class EditorAssetUtil
	{
		/// <summary>
		/// Marks an object as dirty and saves all modified assets to disk.
		/// </summary>
		/// <param name="pObj">The object to mark as dirty.</param>
		public static void Save(Object pObj)
		{
			EditorUtility.SetDirty(pObj);
			AssetDatabase.SaveAssets();
		}

		/// <summary>
		/// Marks an object as dirty and saves all modified assets to disk. Alias for `Save`.
		/// </summary>
		/// <param name="obj">The object to mark as dirty.</param>
		public static void SaveAsset(Object obj)
		{
			EditorUtility.SetDirty(obj);
			AssetDatabase.SaveAssets();
		}

		/// <summary>
		/// Creates a new ScriptableObject asset of a specified type at a given path.
		/// </summary>
		/// <typeparam name="T">The type of ScriptableObject to create.</typeparam>
		/// <param name="path">The full asset path, including the file name and ".asset" extension (e.g., "Assets/Data/NewObject.asset").</param>
		/// <returns>The newly created ScriptableObject instance.</returns>
		public static T CreateScriptableAsset<T>(string path) where T : ScriptableObject
		{
			var asset = ScriptableObject.CreateInstance<T>();

			var directoryPath = Path.GetDirectoryName(path);
			if (!Directory.Exists(directoryPath))
				if (directoryPath != null)
					Directory.CreateDirectory(directoryPath);

			AssetDatabase.CreateAsset(asset, path);
			AssetDatabase.SaveAssets();
			EditorUtility.FocusProjectWindow();
			return asset;
		}

		/// <summary>Caches the parent folder name for a given object to speed up repeated lookups.</summary>
		private static Dictionary<int, string> m_ObjectFolderCaches;

		/// <summary>
		/// Gets the name of the immediate parent folder for a given asset object.
		/// Results are cached for performance.
		/// </summary>
		/// <param name="pObj">The asset object.</param>
		/// <returns>The name of the parent folder.</returns>
		public static string GetObjectFolderName(Object pObj)
		{
			m_ObjectFolderCaches ??= new Dictionary<int, string>();
			if (m_ObjectFolderCaches.ContainsKey(pObj.GetInstanceID()))
				return m_ObjectFolderCaches[pObj.GetInstanceID()];

			var path = AssetDatabase.GetAssetPath(pObj);
			var pathWithoutFilename = Path.GetDirectoryName(path);
			var pathSplit = pathWithoutFilename.Split(Path.DirectorySeparatorChar);
			string folder = pathSplit[pathSplit.Length - 1];
			m_ObjectFolderCaches.Add(pObj.GetInstanceID(), folder);
			return folder;
		}

		/// <summary>
		/// Clears the cached folder names generated by GetObjectFolderName.
		/// </summary>
		public static void ClearObjectFolderCaches() => m_ObjectFolderCaches?.Clear();

		/// <summary>
		/// Loads the main asset at a specified path using AssetDatabase.
		/// </summary>
		/// <param name="path">The full asset path (e.g., "Assets/Textures/MyTexture.png").</param>
		/// <returns>The loaded asset as a UnityEngine.Object, or null if not found.</returns>
		public static Object LoadAsset(string path)
		{
			if (string.IsNullOrEmpty(path)) return null;
			return AssetDatabase.LoadMainAssetAtPath(path);
		}

		/// <summary>
		/// Loads an asset of a specified type from a given path.
		/// This generic version handles casting and retrieving components from GameObjects.
		/// </summary>
		/// <typeparam name="T">The type of asset to load.</typeparam>
		/// <param name="path">The full asset path.</param>
		/// <returns>The loaded asset cast to type T, or null if not found or if casting fails.</returns>
		public static T LoadAsset<T>(string path) where T : Object
		{
			var obj = LoadAsset(path);
			if (obj == null) return null;

			var val = obj as T;
			if (val != null) return val;

			if (typeof(T).IsSubclassOf(typeof(Component)))
				if (obj is GameObject go)
					return go.GetComponent(typeof(T)) as T;

			return null;
		}

		/// <summary>
		/// Gets the GUID for a given asset object.
		/// </summary>
		/// <param name="obj">The asset object.</param>
		/// <returns>The asset's GUID as a string, or null if the object is not a persistent asset.</returns>
		public static string ObjectToGuid(Object obj)
		{
			string path = AssetDatabase.GetAssetPath(obj);
			return !string.IsNullOrEmpty(path) ? AssetDatabase.AssetPathToGUID(path) : null;
		}

		/// <summary>
		/// Extracts individual sprites from a texture sheet (multiple sprite mode) and saves them as separate PNG files.
		/// </summary>
		/// <param name="pObj">The source Texture2D asset configured with multiple sprites.</param>
		/// <param name="pExportDirectory">The directory to save the new sprites. If null, the source directory is used.</param>
		/// <param name="pNamePattern">An optional naming pattern for the exported sprites. If it contains a number, it will be formatted.</param>
		/// <param name="pRenameOriginal">If true, attempts to rename sprite references in the original texture's .meta file to match the new sprite names.</param>
		public static void ExportSpritesFromTexture(Object pObj, string pExportDirectory = null, string pNamePattern = null, bool pRenameOriginal = false)
		{
			var results = new List<Sprite>();
			string path = AssetDatabase.GetAssetPath(pObj);
			var sprites = AssetDatabase.LoadAllAssetsAtPath(path).OfType<Sprite>().ToArray();
			if (sprites.Length > 0)
			{
				if (string.IsNullOrEmpty(pExportDirectory))
					pExportDirectory = Path.GetDirectoryName(path);
				var texture2D = AssetDatabase.LoadAssetAtPath<Texture2D>(path);
				if (!texture2D.isReadable)
					SetTextureReadable(texture2D, true);
				// Create and save new textures for each sprite from the sprite sheet.
				foreach (var sprite in sprites)
				{
					int x = (int)sprite.rect.x;
					int y = (int)sprite.rect.y;
					int width = (int)sprite.rect.width;
					int height = (int)sprite.rect.height;
					var newTexture = new Texture2D(width, height, TextureFormat.RGBA32, false);
					var pixels = sprite.texture.GetPixels(x, y, width, height);
					newTexture.SetPixels(pixels);
					newTexture.Apply();
					byte[] newTextureData = newTexture.EncodeToPNG();

					string customName = sprite.name;
					// Apply custom naming pattern if provided.
					if (!string.IsNullOrEmpty(pNamePattern))
					{
						var match = Regex.Match(customName, @"\d+$");
						if (match.Success)
						{
							int number = int.Parse(match.Value);
							string numberStr = number.ToString();
							if (sprites.Length > 100)
								numberStr = number.ToString("D3");
							else if (sprites.Length > 10)
								numberStr = number.ToString("D2");
							customName = pNamePattern + numberStr;
						}
					}
					string newSpritePath = Path.Combine(pExportDirectory, $"{customName}.png");
					File.WriteAllBytes(newSpritePath, newTextureData);
					Object.DestroyImmediate(newTexture);
				}
				AssetDatabase.Refresh();
				string[] metaFileContent = null;
				if (pRenameOriginal)
					metaFileContent = ReadMetaFile(pObj);

				// Re-import the newly created sprites and apply the original pivot/border settings.
				foreach (var sprite in sprites)
				{
					string customName = sprite.name;
					// Apply custom naming pattern again to find the new files.
					if (!string.IsNullOrEmpty(pNamePattern))
					{
						var match = Regex.Match(customName, @"\d+$");
						if (match.Success)
						{
							int number = int.Parse(match.Value);
							string numberStr = number.ToString();
							if (sprites.Length > 100)
								numberStr = number.ToString("D3");
							else if (sprites.Length > 10)
								numberStr = number.ToString("D2");
							customName = pNamePattern + numberStr;
						}
					}
					string newSpritePath = Path.Combine(pExportDirectory, $"{customName}.png");
					var newSprite = AssetDatabase.LoadAssetAtPath<Sprite>(newSpritePath);
					CopyPivotAndBorder(sprite, newSprite, false);
					results.Add(newSprite);

					// Update the original meta file content if renaming is requested.
					if (pRenameOriginal)
					{
						for (int line = 0; line < metaFileContent.Length; line++)
						{
							string pattern = $@"\b{sprite.name}\b";
							metaFileContent[line] = Regex.Replace(metaFileContent[line], pattern, customName);
						}
					}
				}
				// Write the modified content back to the original meta file.
				if (pRenameOriginal)
				{
					string projectPath = Application.dataPath.Replace("/Assets", "");
					string metaPath = $"{projectPath}\\{AssetDatabase.GetAssetPath(pObj)}.meta";
					File.WriteAllLines(metaPath, metaFileContent);
				}
				AssetDatabase.Refresh();
			}
		}

		/// <summary>
		/// Copies the pivot, border, and alignment settings from one sprite's .meta file to another's.
		/// This works by directly reading and modifying the text-based .meta files.
		/// </summary>
		/// <param name="pOriginal">The source sprite with the desired settings.</param>
		/// <param name="pTarget">The target sprite to apply the settings to.</param>
		/// <param name="pRefreshDatabase">If true, AssetDatabase.Refresh() is called after modifying the meta file to apply changes.</param>
		public static void CopyPivotAndBorder(Sprite pOriginal, Sprite pTarget, bool pRefreshDatabase)
		{
			// First, extract the metadata from the original sprite's .meta file.
			var spriteInfo = GetPivotsOfSprites(pOriginal);
			var pivotForm = spriteInfo[pOriginal.name].pivot;
			var borderFrom = spriteInfo[pOriginal.name].border;
			var alignmentFrom = spriteInfo[pOriginal.name].alignment;

			// Read the entire .meta file of the target sprite.
			var lines = ReadMetaFile(pTarget);
			var nameLines = lines.Where(line => line.Trim().StartsWith("name:", StringComparison.OrdinalIgnoreCase)).ToList();

			// Check if the target is part of a sprite atlas (multiple 'name:' entries in meta).
			if (nameLines.Count > 0) //SpriteTo is inside a atlas
			{
				int nameIndex = 0;
				bool foundName = false;
				// Iterate through the meta file lines to find and replace the target sprite's specific settings.
				for (int i = 0; i < lines.Length; i++)
				{
					bool found = false;
					int spaceIndex = 0;
					// Find the line that defines the target sprite's name within the atlas.
					if (lines[i].Trim().StartsWith("name:", StringComparison.OrdinalIgnoreCase))
					{
						string name = lines[i].Replace("name:", "").Trim();
						if (name == pTarget.name)
						{
							nameIndex = i;
							foundName = true;
						}
					}
					// Once the correct sprite is found, look for its alignment, pivot, and border lines that follow.
					if (foundName && i > nameIndex && lines[i].Trim().StartsWith("alignment:", StringComparison.OrdinalIgnoreCase))
					{
						spaceIndex = lines[i].IndexOf("alignment:", StringComparison.OrdinalIgnoreCase);
						lines[i] = $"alignment: {alignmentFrom}"; //Replace alignment
					}
					else if (foundName && i > nameIndex && lines[i].Trim().StartsWith("pivot:", StringComparison.OrdinalIgnoreCase))
					{
						if (alignmentFrom == 0 && pivotForm == Vector2.zero) // Don't write a zero pivot for center alignment
							continue;
						spaceIndex = lines[i].IndexOf("pivot:", StringComparison.OrdinalIgnoreCase);
						lines[i] = $"pivot: {{x: {pivotForm.x}, y: {pivotForm.y}}}"; //Replace pivot
					}
					else if (foundName && i > nameIndex && lines[i].Trim().StartsWith("border:", StringComparison.OrdinalIgnoreCase))
					{
						spaceIndex = lines[i].IndexOf("border:", StringComparison.OrdinalIgnoreCase);
						lines[i] = $"border: {{x: {borderFrom.x}, y: {borderFrom.y}, z: {borderFrom.z}, w: {borderFrom.w}}}"; //Replace border
						found = true;
					}
					// Preserve the original indentation of the line.
					if (spaceIndex > 0)
					{
						for (int s = 0; s < spaceIndex; s++)
							lines[i] = lines[i].Insert(0, " ");
					}
					if (found)
						break; // Stop after finding and replacing all properties for this sprite.
				}
			}
			else // The target is a single sprite texture.
			{
				for (int i = 0; i < lines.Length; i++)
				{
					bool found = false;
					int spaceIndex = 0;
					// Find and replace the relevant properties for a single sprite.
					if (lines[i].Trim().StartsWith("alignment:", StringComparison.OrdinalIgnoreCase))
					{
						spaceIndex = lines[i].IndexOf("alignment:", StringComparison.OrdinalIgnoreCase);
						lines[i] = $"alignment: {alignmentFrom}";
					}
					else if (lines[i].Trim().StartsWith("spritePivot:", StringComparison.OrdinalIgnoreCase))
					{
						if (alignmentFrom == 0 && pivotForm == Vector2.zero)
							continue;
						spaceIndex = lines[i].IndexOf("spritePivot:", StringComparison.OrdinalIgnoreCase);
						lines[i] = $"spritePivot: {{x: {pivotForm.x}, y: {pivotForm.y}}}";
					}
					else if (lines[i].Trim().StartsWith("spriteBorder:", StringComparison.OrdinalIgnoreCase))
					{
						spaceIndex = lines[i].IndexOf("spriteBorder:", StringComparison.OrdinalIgnoreCase);
						// Note: Original code has 'y:' twice, this is preserved. It should likely be 'w:'.
						lines[i] = $"spriteBorder: {{x: {borderFrom.x}, y: {borderFrom.y}, z: {borderFrom.z}, y: {borderFrom.w}}}";
						found = true;
					}
					// Preserve indentation.
					if (spaceIndex > 0)
						for (int s = 0; s < spaceIndex; s++)
							lines[i] = lines[i].Insert(0, " ");
					if (found)
						break;
				}
			}

			// Write the modified lines back to the target's .meta file.
			WriteMetaFile(pTarget, lines, pRefreshDatabase);
		}

		/// <summary>
		/// Modifies a texture's .meta file to set its "Read/Write Enabled" flag.
		/// </summary>
		/// <param name="p_texture2D">The texture asset to modify.</param>
		/// <param name="p_readable">The desired readable state (true for enabled, false for disabled).</param>
		public static void SetTextureReadable(Texture2D p_texture2D, bool p_readable)
		{
			var lines = ReadMetaFile(p_texture2D);
			for (int i = 0; i < lines.Length; i++)
			{
				// Find the line containing the isReadable property.
				if (lines[i].Trim().StartsWith("isReadable:", StringComparison.OrdinalIgnoreCase))
				{
					int spaceIndex = lines[i].IndexOf("isReadable:", StringComparison.OrdinalIgnoreCase);
					string readable = p_readable ? "1" : "0";
					lines[i] = $"isReadable: {readable}"; // Replace the value.
					// Preserve indentation.
					for (int s = 0; s < spaceIndex; s++)
						lines[i] = lines[i].Insert(0, " ");
					break;
				}
			}
			// Write the changes and re-import the asset.
			WriteMetaFile(p_texture2D, lines, true);
		}

		/// <summary>
		/// Reads all lines from an asset's corresponding .meta file.
		/// </summary>
		/// <param name="pObject">The asset object.</param>
		/// <returns>An array of strings, where each string is a line from the .meta file.</returns>
		public static string[] ReadMetaFile(Object pObject)
		{
			string projectPath = Application.dataPath.Replace("/Assets", "");
			string path = $"{projectPath}\\{AssetDatabase.GetAssetPath(pObject)}";
			string metaPath = $"{path}.meta";
			string[] lines = File.ReadAllLines(metaPath);
			return lines;
		}

		/// <summary>
		/// Writes an array of strings to an asset's corresponding .meta file, overwriting its contents.
		/// </summary>
		/// <param name="pObject">The asset object.</param>
		/// <param name="pLines">The lines to write to the .meta file.</param>
		/// <param name="pRefreshDatabase">If true, AssetDatabase.Refresh() is called after writing to apply the changes.</param>
		public static void WriteMetaFile(Object pObject, string[] pLines, bool pRefreshDatabase)
		{
			string projectPath = Application.dataPath.Replace("/Assets", "");
			string path = $"{projectPath}\\{AssetDatabase.GetAssetPath(pObject)}";
			string metaPath = $"{path}.meta";
			File.WriteAllLines(metaPath, pLines);
			if (pRefreshDatabase)
				AssetDatabase.Refresh();
		}

		/// <summary>
		/// Reads the entire content of an asset's .meta file as a single string.
		/// </summary>
		/// <param name="pObject">The asset object.</param>
		/// <returns>The full text content of the .meta file.</returns>
		public static string ReadContentMetaFile(Object pObject)
		{
			string projectPath = Application.dataPath.Replace("/Assets", "");
			string path = $"{projectPath}\\{AssetDatabase.GetAssetPath(pObject)}";
			string metaPath = $"{path}.meta";
			string content = File.ReadAllText(metaPath);
			return content;
		}

		/// <summary>
		/// A struct to hold metadata for a Sprite, extracted from its .meta file.
		/// </summary>
		public struct SpriteInfo
		{
			public string name;
			public Vector2 pivot;
			public Vector4 border;
			public int alignment;
		}

		/// <summary>
		/// Parses the .meta file of a sprite or sprite atlas to extract the pivot, border, and alignment for all contained sprites.
		/// </summary>
		/// <param name="pSpriteFrom">A sprite from the texture asset whose .meta file should be read.</param>
		/// <returns>A dictionary mapping sprite names to their SpriteInfo metadata.</returns>
		public static Dictionary<string, SpriteInfo> GetPivotsOfSprites(Sprite pSpriteFrom)
		{
			var results = new Dictionary<string, SpriteInfo>();
			var lines = ReadMetaFile(pSpriteFrom);
			var nameLines = lines.Where(line => line.Trim().StartsWith("name:", StringComparison.OrdinalIgnoreCase)).ToList();

			// If 'name' entries exist, we assume it's a sprite atlas.
			if (nameLines.Count > 0) //SpriteFrom is inside a atlas
			{
				//Get names of all sprites inside atlas which contain spriteFrom
				var names = new List<string>();
				foreach (var line in nameLines)
				{
					string name = line.Replace("name: ", "").Trim();
					names.Add(name);
				}

				// Get alignment data for each sprite.
				var alignmentLines = lines.Where(line => line.Trim().StartsWith("alignment:", StringComparison.OrdinalIgnoreCase)).ToList();
				var alignments = new List<int>();
				for (int i = 0; i < alignmentLines.Count; i++)
				{
					if (i == 0) // Skip the global alignment setting.
						continue;
					string line = alignmentLines[i];
					var alignmentStr = line.Replace("alignment: ", "").Trim();
					alignments.Add(int.Parse(alignmentStr));
				}

				//Get pivots of all sprites inside atlas which contain spriteFrom
				var pivotLines = lines.Where(line => line.Trim().StartsWith("pivot:", StringComparison.OrdinalIgnoreCase)).ToList();
				var pivots = new List<Vector2>();
				foreach (var line in pivotLines)
				{
					var pivotStr = line.Replace("pivot: ", "").Trim();
					// Note: Assumes RVector2 is a simple serializable struct with public x, y fields.
					var pivot = JsonUtility.FromJson<RVector2>(pivotStr);
					pivots.Add(new Vector2(pivot.x, pivot.y));
				}

				// Get border data for each sprite.
				var borders = new List<Vector4>();
				var borderLines = lines.Where(line => line.Trim().StartsWith("border:", StringComparison.OrdinalIgnoreCase)).ToList();
				foreach (var line in borderLines)
				{
					var borderStr = line.Replace("border: ", "").Trim();
					// Note: Assumes RVector4 is a simple serializable struct with public x, y, z, w fields.
					var border = JsonUtility.FromJson<RVector4>(borderStr);
					borders.Add(new Vector4(border.x, border.y, border.z, border.w));
				}

				// Combine the parsed data into SpriteInfo structs.
				for (int i = 0; i < names.Count; i++)
					results.Add(names[i], new SpriteInfo
					{
						name = names[i],
						pivot = pivots[i],
						border = borders[i],
						alignment = alignments[i],
					});
			}
			else // It's a single sprite texture.
			{
				// Find the single alignment, pivot, and border properties.
				var alignmentLine = lines.First(line => line.Trim().StartsWith("alignment: ", StringComparison.OrdinalIgnoreCase));
				var alignmentStr = alignmentLine.Replace("alignment: ", "").Trim();
				var alignment = int.Parse(alignmentStr);

				var pivotLine = lines.First(line => line.Trim().StartsWith("spritePivot: ", StringComparison.OrdinalIgnoreCase));
				var pivotStr = pivotLine.Replace("spritePivot: ", "").Trim();
				var pivot = JsonUtility.FromJson<RVector2>(pivotStr);

				var borderStr = lines.First(line => line.Trim().StartsWith("spriteBorder: ", StringComparison.OrdinalIgnoreCase));
				var border = JsonUtility.FromJson<RVector4>(borderStr);

				results.Add(pSpriteFrom.name, new SpriteInfo
				{
					name = pSpriteFrom.name,
					pivot = new Vector2(pivot.x, pivot.y),
					border = new Vector4(border.x, border.y, border.z, border.w),
					alignment = alignment,
				});
			}
			return results;
		}

		/// <summary>Caches a map of asset GUIDs to the paths of assets that reference them. Used for GUID replacement.</summary>
		private static Dictionary<string, HashSet<string>> m_InverseReferenceMap;
		/// <summary>The total number of references found when building the inverse reference map.</summary>
		private static int m_ReferencesCount;

		/// <summary>
		/// Searches the project for all references to a list of old objects and replaces them with a reference to a new object.
		/// This works by directly modifying the GUID and FileID strings in serialized asset files.
		/// </summary>
		/// <typeparam name="T">The type of the objects.</typeparam>
		/// <param name="oldObjects">A list of objects whose references should be replaced.</param>
		/// <param name="newObject">The object to reference instead.</param>
		/// <param name="assetGUIDs">An optional list of asset GUIDs to search within. If null, the entire project is scanned.</param>
		/// <returns>A dictionary mapping the paths of updated assets to the number of replacements made in each.</returns>
		public static Dictionary<string, int> SearchAndReplaceGuid<T>(List<T> oldObjects, T newObject, string[] assetGUIDs) where T : Object
		{
			// If no specific assets to search are provided, search the entire project.
			if (assetGUIDs == null)
			{
				const string searchFilter = "t:Object";
				string[] searchDirectories = { "Assets" };
				assetGUIDs = AssetDatabase.FindAssets(searchFilter, searchDirectories);
			}
			var updatedAssets = new Dictionary<string, int>();

			if (oldObjects.Count == 0)
				return updatedAssets;

			var inverseReferenceMap = new Dictionary<string, HashSet<string>>();
			int referencesCount = 0;
			// If an inverse reference map is not already cached, build one.
			if (m_InverseReferenceMap == null)
			{
				// Initialize map to store all paths that have a reference to our old objects.
				foreach (var selectedObj in oldObjects)
				{
					if (selectedObj == null)
						continue;
					string selectedPath = AssetDatabase.GetAssetPath(selectedObj);
					string selectedGuid = AssetDatabase.AssetPathToGUID(selectedPath);
					inverseReferenceMap[selectedGuid] = new HashSet<string>();
				}

				// Scan all specified assets and store the inverse reference if it contains a reference to any old object.
				var scanProgress = 0;
				foreach (var guid in assetGUIDs)
				{
					scanProgress++;
					var path = AssetDatabase.GUIDToAssetPath(guid);
					if (IsDirectory(path))
						continue;

					var dependencies = AssetDatabase.GetDependencies(path);
					foreach (var dependency in dependencies)
					{
						EditorUtility.DisplayProgressBar("Scanning guid references on:", path, (float)scanProgress / assetGUIDs.Length);

						var dependencyGuid = AssetDatabase.AssetPathToGUID(dependency);
						if (inverseReferenceMap.ContainsKey(dependencyGuid))
						{
							inverseReferenceMap[dependencyGuid].Add(path);

							// The commented-out code below could be used to also include .meta files in the search,
							// which can be useful for certain asset types like FBXs with external materials.
							// var metaPath = AssetDatabase.GetTextMetaFilePathFromAssetPath(path);
							// inverseReferenceMap[dependencyGUID].Add(metaPath);

							referencesCount++;
						}
					}
				}
			}
			else
			{
				// Use the pre-built cache.
				inverseReferenceMap = m_InverseReferenceMap;
				referencesCount = m_ReferencesCount;
			}

			// Get the GUID and FileID for the new object that will replace the old ones.
			string newPath = AssetDatabase.GetAssetPath(newObject);
			string newGuid = AssetDatabase.AssetPathToGUID(newPath);
			AssetDatabase.TryGetGUIDAndLocalFileIdentifier(newObject, out string assetId, out long newFileId);
			var countProgress = 0;
			int countReplaced = 0;
			// Iterate through each old object to be replaced.
			foreach (var selectedObj in oldObjects)
			{
				if (selectedObj == null)
					continue;
				bool found = false;
				string selectedPath = AssetDatabase.GetAssetPath(selectedObj);
				string selectedGuid = AssetDatabase.AssetPathToGUID(selectedPath);
				AssetDatabase.TryGetGUIDAndLocalFileIdentifier(selectedObj, out assetId, out long selectedFileId);
				var referencePaths = inverseReferenceMap[selectedGuid];
				// Iterate through all assets that reference the current old object.
				foreach (var referencePath in referencePaths)
				{
					if (referencePath == selectedPath)
						continue;

					countProgress++;

					EditorUtility.DisplayProgressBar($"Replacing GUID: {selectedPath}", referencePath, (float)countProgress / referencesCount);

					if (IsDirectory(referencePath))
						continue;

					var contents = File.ReadAllText(referencePath);

					// Perform the text-based replacement of the GUID and FileID pair.
					if (contents.Contains($"fileID: {selectedFileId}, guid: {selectedGuid}"))
					{
						contents = contents.Replace($"fileID: {selectedFileId}, guid: {selectedGuid}", $"fileID: {newFileId}, guid: {newGuid}");
						File.WriteAllText(referencePath, contents);
						countReplaced++;
						found = true;
					}
				}

				UnityEngine.Debug.Log($"Replace GUID in: {selectedPath}");
				updatedAssets.Add(selectedPath, countReplaced);

				if (found)
					EditorUtility.SetDirty(selectedObj);
			}
			return updatedAssets;
		}

		/// <summary>
		/// Scans the project to build a cache of which assets reference a given list of objects.
		/// This is a preparatory step that populates the internal `m_InverseReferenceMap` for later use by `SearchAndReplaceGuid`.
		/// </summary>
		/// <typeparam name="T">The type of the objects to track references to.</typeparam>
		/// <param name="assetGUIDs">An optional list of asset GUIDs to search within. If null, the entire project is scanned.</param>
		/// <param name="cachedObjects">The list of objects whose references should be tracked.</param>
		public static void BuildReferenceMapCache<T>(string[] assetGUIDs, List<T> cachedObjects) where T : Object
		{
			if (assetGUIDs == null)
			{
				const string searchFilter = "t:Object";
				string[] searchDirectories = { "Assets" };
				assetGUIDs = AssetDatabase.FindAssets(searchFilter, searchDirectories);
			}

			m_InverseReferenceMap = new Dictionary<string, HashSet<string>>();
			m_ReferencesCount = 0;

			// Initialize map to store all paths that have a reference to our selectedGuids
			foreach (var selectedObj in cachedObjects)
			{
				string selectedPath = AssetDatabase.GetAssetPath(selectedObj);
				string selectedGuid = AssetDatabase.AssetPathToGUID(selectedPath);
				m_InverseReferenceMap[selectedGuid] = new HashSet<string>();
			}

			// Scan all assets and store the inverse reference if it contains a reference to any selectedGuid...
			var scanProgress = 0;
			foreach (var guid in assetGUIDs)
			{
				scanProgress++;
				var path = AssetDatabase.GUIDToAssetPath(guid);
				if (IsDirectory(path))
					continue;

				var dependencies = AssetDatabase.GetDependencies(path);
				foreach (var dependency in dependencies)
				{
					EditorUtility.DisplayProgressBar("Scanning guid references on:", path, (float)scanProgress / assetGUIDs.Length);

					var dependencyGuid = AssetDatabase.AssetPathToGUID(dependency);
					if (m_InverseReferenceMap.ContainsKey(dependencyGuid))
					{
						m_InverseReferenceMap[dependencyGuid].Add(path);

						// Also include .meta path. This fixes broken references when an FBX uses external materials
						// var metaPath = AssetDatabase.GetTextMetaFilePathFromAssetPath(path);
						// inverseReferenceMap[dependencyGUID].Add(metaPath);

						m_ReferencesCount++;
					}
				}
			}
		}

		/// <summary>
		/// Finds all assets matching a filter in a specified folder, marks them as dirty, and saves them.
		/// This can be used to force a re-serialization of assets.
		/// </summary>
		/// <param name="filter">The asset search filter (e.g., "t:Material").</param>
		/// <param name="folderPath">The folder to search in. If null, a folder selection dialog is shown.</param>
		public static void RefreshAssets(string filter, string folderPath = null)
		{
			if (string.IsNullOrEmpty(folderPath))
			{
				folderPath = EditorFileUtil.OpenFolderPanel();
				if (string.IsNullOrEmpty(folderPath))
					return;
				folderPath = EditorFileUtil.FormatPathToUnityPath(folderPath);
			}
			var assetGUIDs = AssetDatabase.FindAssets(filter, new[] { folderPath });
			foreach (string guid in assetGUIDs)
			{
				var path = AssetDatabase.GUIDToAssetPath(guid);
				var asset = AssetDatabase.LoadAssetAtPath<Object>(path);
				if (asset != null)
					EditorUtility.SetDirty(asset);
			}
			AssetDatabase.SaveAssets();
		}

		/// <summary>
		/// Applies `RefreshAssets` to the currently selected folder(s) in the Project window.
		/// </summary>
		/// <param name="filter">The asset search filter (e.g., "t:Prefab").</param>
		public static void RefreshAssetsInSelectedFolder(string filter)
		{
			var objects = Selection.GetFiltered(typeof(Object), SelectionMode.Assets);
			if (objects.Length == 0)
				return;
			for (int i = 0; i < objects.Length; i++)
			{
				var obj = objects[i];
				bool isFolder = AssetDatabase.IsValidFolder(AssetDatabase.GetAssetPath(obj));
				if (isFolder)
				{
					string directoryPath = AssetDatabase.GetAssetPath(obj);
					RefreshAssets(filter, directoryPath);
				}
			}
		}

		/// <summary>
		/// Exports the currently selected folder(s) in the Project window to a .unitypackage file.
		/// </summary>
		public static void ExportSelectedFoldersToUnityPackage()
		{
			var objects = Selection.GetFiltered(typeof(Object), SelectionMode.Assets);
			if (objects.Length == 0)
				return;

			var folders = new List<string>();
			for (int i = 0; i < objects.Length; i++)
			{
				var obj = objects[i];
				bool isFolder = AssetDatabase.IsValidFolder(AssetDatabase.GetAssetPath(obj));
				if (isFolder)
					folders.Add(AssetDatabase.GetAssetPath(obj));
			}
			if (folders.Count > 0)
			{
				string directoryPath = AssetDatabase.GetAssetPath(objects[0]);
				string packagePath = EditorUtility.SaveFilePanel("Export Unity Package", directoryPath, objects[0].name + ".unitypackage", "unitypackage");
				AssetDatabase.ExportPackage(folders.ToArray(), packagePath, ExportPackageOptions.Recurse | ExportPackageOptions.Interactive);
			}
		}

		/// <summary>
		/// Retrieves all assets of a specific type from a given path and its subdirectories.
		/// </summary>
		/// <example> `GetObjects<AudioClip>(@"Assets\Game\Sounds\Musics", "t:AudioClip")` </example>
		/// <typeparam name="T">The type of asset to retrieve.</typeparam>
		/// <param name="pPath">The root directory path to search within.</param>
		/// <param name="filter">The asset search filter string (e.g., "t:Texture2D").</param>
		/// <param name="getChild">If true, loads all sub-assets (e.g., sprites in a texture); if false, loads only the main asset.</param>
		/// <returns>A list of found assets of type T.</returns>
		public static List<T> GetObjects<T>(string pPath, string filter, bool getChild = true)
			where T : Object
		{
			var directories = EditorFileUtil.GetDirectories(pPath);

			var list = new List<T>();

			var resources = AssetDatabase.FindAssets(filter, directories);

			foreach (var re in resources)
			{
				if (getChild)
				{
					var childAssets = AssetDatabase.LoadAllAssetsAtPath(AssetDatabase.GUIDToAssetPath(re));
					foreach (var child in childAssets)
					{
						if (child is T o)
						{
							list.Add(o);
						}
					}
				}
				else
				{
					list.Add(Assign<T>(AssetDatabase.GUIDToAssetPath(re)));
				}
			}

			return list;
		}

		/// <summary>Internal helper to load an asset at a path and cast it to the specified type.</summary>
		private static T Assign<T>(string pPath) where T : Object
		{
			return AssetDatabase.LoadAssetAtPath(pPath, typeof(T)) as T;
		}

		/// <summary>
		/// Checks if a given file system path points to a directory.
		/// </summary>
		/// <param name="path">The path to check.</param>
		/// <returns>True if the path is a directory, otherwise false.</returns>
		public static bool IsDirectory(string path) => File.GetAttributes(path).HasFlag(FileAttributes.Directory);

		/// <summary>
		/// Retrieves all animation clip metadata from a model importer's settings.
		/// </summary>
		/// <param name="pPath">The asset path to the model file (e.g., FBX).</param>
		/// <returns>An array of ModelImporterClipAnimation data, or null if the asset is not a model.</returns>
		public static ModelImporterClipAnimation[] GetAnimationsFromModel(string pPath)
		{
			var mi = AssetImporter.GetAtPath(pPath) as ModelImporter;
			if (mi != null)
				return mi.defaultClipAnimations;
			return null;
		}

		/// <summary>
		/// Loads a specific AnimationClip that is embedded as a sub-asset within a model file.
		/// </summary>
		/// <param name="pPath">The asset path to the model file.</param>
		/// <param name="pName">The name of the animation clip to load.</param>
		/// <returns>The found AnimationClip, or null if it does not exist.</returns>
		public static AnimationClip GetAnimationFromModel(string pPath, string pName)
		{
			// The commented out code represents an alternative approach via model importer settings.
			//var anims = GetAnimationsFromModel(pPath);
			//if (anims != null)
			//    foreach (var anim in anims)
			//        if (anim.name == pName)
			//            return anim;
			//return null;

			var representations = AssetDatabase.LoadAllAssetRepresentationsAtPath(pPath);
			foreach (var asset in representations)
			{
				var clip = asset as AnimationClip;
				if (clip != null && clip.name == pName)
					return clip;
			}

			return null;
		}

		/// <summary>
		/// Retrieves all embedded AnimationClips from the currently selected model assets in the Project window.
		/// </summary>
		/// <returns>A list of all found animation clips from the selected assets.</returns>
		public static List<AnimationClip> GetAnimClipsFromFBX()
		{
			var list = new List<AnimationClip>();
			var selections = Selection.objects;
			foreach (var s in selections)
			{
				var path = AssetDatabase.GetAssetPath(s);
				var representations = AssetDatabase.LoadAllAssetRepresentationsAtPath(path);
				foreach (var asset in representations)
				{
					var clip = asset as AnimationClip;
					if (clip != null)
						list.Add(clip);
				}
			}

			return list;
		}
	}
}
#endif